type ConcurrentQueueWorkload<T> = () => ConcurrentQueueWorkloadPromise<T>;
type ConcurrentQueueWorkloadPromise<T> = Promise<T>;
type ConcurrentQueueWorkloadResult<T> = ConcurrentQueueWorkloadFulfilledResult<T> | ConcurrentQueueWorkloadRejectedResult;
interface ConcurrentQueueWorkloadFulfilledResult<T> extends PromiseFulfilledResult<T> {
    reason?: never;
}
interface ConcurrentQueueWorkloadRejectedResult extends PromiseRejectedResult {
    value?: never;
}
export declare class ConcurrentQueue<T = any> {
    readonly concurrency: number;
    private inProgressWorkloadPromises;
    private enqueuedWorkloads;
    constructor(concurrency: number);
    static processWorkloads<T>(concurrency: number, workloads: ConcurrentQueueWorkload<T>[]): Promise<ConcurrentQueueWorkloadResult<T>[]>;
    enqueue(workload: ConcurrentQueueWorkload<T>): void;
    process(): Promise<ConcurrentQueueWorkloadResult<T>[]>;
    private run;
    private dequeueInProgressWorkloadPromise;
}
export {};
