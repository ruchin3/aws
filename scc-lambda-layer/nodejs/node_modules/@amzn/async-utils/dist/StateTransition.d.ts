export type Subscription = {
    unsubscribe: () => void;
};
type Callback<T> = (value: T, previousValue?: T) => any;
/**
 * StateTransitions are observable state values which optionally allow you \
 * to guard against moving into invalid states. They expose a subscription \
 * API for event-listener style reactions as well as async functions to be \
 * used with async workflows.
 *
 * ```
 * const toggleState = new StateTransition<boolean>(false);
 *
 * // logs `false` right away, and logs any future changes
 * const sub = toggleState.subscribe(state => console.log(state));
 *
 * // unsubscribe from future transitions
 * sub.unsubscribe();
 *
 * // only logs future transitions
 * toggleState.subscribeNext(state => console.log(state));
 *
 * // resolves once state is true; resolves immediately if the current state passes filter
 * await toggleState.when(state => state === true)
 *
 * // resolves on the next state transition
 * await toggleState.whenNext()
 *
 * // resolves once the state transitions to a value the passes filter; ignores current
 * await toggleState.whenNext(state => !state)
 *
 * // the previous statement does not resolve since it only resolves on false
 * // the second and third previous statements will resolve
 * toggleState.next(true);
 *
 * // prevents further state transitions
 * toggleState.complete();
 * toggleState.isComplete; // true
 *
 * // get the current value
 * toggleState.value
 * ```
 *
 * For state guards, pass in a function which takes the current and next values
 * and returns true if the state transition should be allowed:
 *
 * ```
 * const countUp = new StateTransition(0, (curr, next) => next > curr);
 * countUp.next(1); // changes state, returns true
 * countUp.next(2); // changes state, returns true
 * countUp.next(1); // invalid state, returns false
 * ```
 *
 */
export declare class StateTransition<States = any> {
    private readonly initialValue;
    private isNextValueValid;
    static throwOnInvalid: boolean;
    private _complete;
    private _value;
    get value(): States;
    constructor(initialValue: States, isNextValueValid?: (currentValue: States, nextValue: States) => boolean);
    /**
     * Optional callback to listen for invalid state changes. \
     * Arguments to callback: (invalidValue, currentValue). \
     * Useful for debugging.
     */
    onInvalid(_invalidValue: States, _value: States): void;
    onComplete(_value: States): void;
    private _nextQueue;
    /** returns true if the state transition is successful */
    next(nextValue: States): boolean;
    private _processing;
    private processNextQueue;
    private _subscriptions;
    /** Subscribe, but skip the current value and wait for the next transition */
    subscribeNext(callback: Callback<States>): Subscription;
    /** Subscribe, and get called immediately with the current value */
    subscribe(callback: Callback<States>): Subscription;
    when<S extends States>(filter: (value: States) => value is S): Promise<S>;
    when(filter: (value: States) => boolean): Promise<States>;
    /** Resolves on next value, that optionally matches a filter */
    whenNext(filter?: (value: States) => boolean): Promise<States>;
    whenNext<S extends States = States>(filter?: (value: States) => value is S): Promise<S>;
    /** Prevents future state transitions */
    complete(): void;
    isComplete(): boolean;
    private completeDfd;
    whenComplete(): Promise<void>;
    reset(): void;
    toString(): string;
}
export {};
