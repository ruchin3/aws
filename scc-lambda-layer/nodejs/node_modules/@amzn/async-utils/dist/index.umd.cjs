(function(a,u){typeof exports=="object"&&typeof module<"u"?u(exports):typeof define=="function"&&define.amd?define(["exports"],u):(a=typeof globalThis<"u"?globalThis:a||self,u(a["async-utils"]={}))})(this,function(a){"use strict";var te=Object.defineProperty;var se=(a,u,m)=>u in a?te(a,u,{enumerable:!0,configurable:!0,writable:!0,value:m}):a[u]=m;var n=(a,u,m)=>(se(a,typeof u!="symbol"?u+"":u,m),m);class u{constructor(){n(this,"_chain",Promise.resolve());n(this,"_unlocker",()=>{});n(this,"_isLocked",!1)}async requestLock(){let e;return this._isLocked=!0,this._chain=this._chain.then(()=>new Promise(t=>{const s=()=>{s===this._unlocker&&(this._isLocked=!1,this._unlocker=()=>{},t())};this._unlocker=s,e(s)})),new Promise(t=>{e=t})}async whenUnlocked(){await this._chain}unlock(){this._unlocker()}get isLocked(){return this._isLocked}}const m="__getStatsInternal__";function W(r){try{const e=r;return typeof e.data.id=="number"&&typeof e.data.method=="string"&&Array.isArray(e.data.params)}catch{return!1}}function b(r){if(W(r))return r.data}function T(r){try{const e=r;return typeof e.data.id=="number"&&("returnValue"in e.data||"error"in e.data)}catch{return!1}}function O(r){if(T(r))return r.data}let q=1;class ${constructor(e){n(this,"worker");n(this,"workerUrl");n(this,"workerOptions");n(this,"onCreateWorker");n(this,"onTerminateWorker");n(this,"onMessageError");n(this,"requestFulfillerMap",{});n(this,"_stats",{pending:0,completed:0,totalDuration:0});n(this,"handleMessage",e=>{const t=O(e);if(t){const{id:s,error:i,returnValue:o}=t,h=this.requestFulfillerMap[s];h&&(i?h.reject(i):h.resolve(o),delete this.requestFulfillerMap[s])}});n(this,"handleMessageError",e=>{var t;(t=this.onMessageError)==null||t.call(this,e)});this.workerUrl=e.workerUrl,this.workerOptions=e.workerOptions,this.onCreateWorker=e.onCreateWorker,this.onMessageError=e.onMessageError,this.onTerminateWorker=e.onTerminateWorker}getOrCreateWorker(){var e;return this.worker||(this.worker=new Worker(this.workerUrl,this.workerOptions),this.worker.addEventListener("message",this.handleMessage),this.worker.addEventListener("messageerror",this.handleMessageError),(e=this.onCreateWorker)==null||e.call(this,this.worker)),this.worker}start(){this.getOrCreateWorker()}terminate(){var e;this.worker&&(this.worker.removeEventListener("message",this.handleMessage),this.worker.removeEventListener("messageerror",this.handleMessageError),this.worker.terminate(),(e=this.onTerminateWorker)==null||e.call(this,this.worker),Object.values(this.requestFulfillerMap).forEach(({reject:t})=>{t(new Error("Worker terminated"))}),this.requestFulfillerMap={},delete this.worker)}async exec(e,t,s){const i=Date.now();this._stats.pending++;const o=this.getOrCreateWorker(),h=q++,l=new Promise((g,f)=>{this.requestFulfillerMap[h]={resolve:g,reject:f}}),d={id:h,method:e,params:t};s?o.postMessage(d,s):o.postMessage(d);const c=()=>{this._stats.totalDuration+=Date.now()-i,this._stats.pending--,this._stats.completed++};return l.then(c,c),l}async getStats(){const e=await this.exec(m,[]),t=this._stats.totalDuration/this._stats.completed;return{...this._stats,avgDuration:t,avgLatency:t-e.avgDuration,totalWorkerDuration:e.totalDuration,diffDuration:this._stats.totalDuration-e.totalDuration}}}class x{constructor(e,t={}){n(this,"handlerMap");n(this,"onMessageError");n(this,"_stats",{pending:0,completed:0,totalDuration:0});n(this,"handleMessage",async e=>{const t=b(e);if(!t)return;this._stats.pending++;const s=Date.now(),{id:i,method:o,params:h}=t,l=this.handlerMap[o];let d,c,g;const f=p=>g=p;if(l)try{d=await l(...h,f)}catch(p){c=p}else c=new Error(`No handler for type ${o}`);const _={id:i,returnValue:d,error:c};this._stats.pending--,this._stats.completed++,this._stats.totalDuration+=Date.now()-s,g?postMessage(_,g):postMessage(_)});n(this,"handleError",e=>{var t;(t=this.onMessageError)==null||t.call(this,e)});n(this,"getStats",()=>({...this._stats,avgDuration:this._stats.totalDuration/this._stats.completed}));if(typeof window<"u"&&window.window===window)throw new Error("AsyncWorkerWorker must run in a worker");this.handlerMap=e,this.handlerMap[m]=this.getStats,this.onMessageError=t.onMessageError,addEventListener("message",this.handleMessage),addEventListener("messageerror",this.handleError)}terminate(){removeEventListener("message",this.handleMessage),removeEventListener("messageerror",this.handleError)}}class M{constructor(e){n(this,"inProgressWorkloadPromises",[]);n(this,"enqueuedWorkloads",[]);this.concurrency=e}static processWorkloads(e,t){const s=new M(e);for(const i of t)s.enqueue(i);return s.process()}enqueue(e){this.enqueuedWorkloads.push(e)}async process(){const e=[];for(const s of this.enqueuedWorkloads){const i=this.run(s);if(e.push(i),this.inProgressWorkloadPromises.push(i),this.inProgressWorkloadPromises.length>=this.concurrency)try{await Promise.race(this.inProgressWorkloadPromises)}catch{}}const t=[];for(const s of e)try{const i=await s;t.push({status:"fulfilled",value:i})}catch(i){t.push({status:"rejected",reason:i})}return t}run(e){const t=e(),s=()=>this.dequeueInProgressWorkloadPromise(t);return t.then(s).catch(s),t}dequeueInProgressWorkloadPromise(e){const t=this.inProgressWorkloadPromises.findIndex(s=>s===e);this.inProgressWorkloadPromises.splice(t,1)}}class w{constructor(){n(this,"_resolver");n(this,"_promise");n(this,"_state","PENDING");n(this,"resolve",e=>{this._state==="PENDING"&&(this._state="FULFILLED",this._resolver({value:e}))});n(this,"reject",e=>{this._state==="PENDING"&&(this._state="REJECTED",this._resolver({reason:e}))});n(this,"then",async(e,t)=>{const{value:s,reason:i}=await this._promise;if(i)if(t)t(i);else throw i;else return e==null||e(s),s});n(this,"catch",e=>this.then(void 0,e));this._promise=new Promise(e=>{this._resolver=e})}static resolve(e){const t=new w;return t.resolve(e),t}static reject(e){const t=new w;return t.reject(e),t}static fromPromise(e){const t=new w;return e.then(s=>t.resolve(s),s=>t.reject(s)),t}get state(){return this._state}get isPending(){return this._state==="PENDING"}get isFulfilled(){return this._state==="FULFILLED"}get isRejected(){return this._state==="REJECTED"}}class L{constructor(){n(this,"_listeners",{});n(this,"throwOnEmitterError",!1)}emit(e,...t){const s=this._listeners[e];return s?(s.forEach(i=>{try{const o=i(t[0]);o&&"then"in o&&typeof o.then=="function"&&o.then(h=>h,h=>{if(this.throwOnEmitterError)throw h})}catch(o){if(this.throwOnEmitterError)throw o}}),s.size):0}on(e,t){return(this._listeners[e]||(this._listeners[e]=new Set)).add(t),()=>this.off(e,t)}once(e,t){if(!t)return new Promise(i=>this.once(e,i));const s=this.on(e,i=>{s(),t(i)});return s}off(e,t){var s;return!!((s=this._listeners[e])!=null&&s.delete(t))}listeners(e){return Array.from(this._listeners[e]??[])}listenerCount(e){var t;return((t=this._listeners[e])==null?void 0:t.size)??0}}const F=()=>{},k=class k{constructor(e,t=()=>!0){n(this,"_complete",!1);n(this,"_value");n(this,"_nextQueue",[]);n(this,"_processing",!1);n(this,"_subscriptions",new Set);n(this,"completeDfd",new w);this.initialValue=e,this.isNextValueValid=t,this._value=e}get value(){return this._value}onInvalid(e,t){}onComplete(e){}next(e){if(this._complete)return!1;const t=this.value;if(t===e)return!1;if(this.isNextValueValid(t,e))return this._nextQueue.push(e),this.processNextQueue(),!0;if(this.onInvalid(e,this.value),k.throwOnInvalid)throw new Error(`StateTransition::next: Invalid state change: ${{currentValue:this._value,nextValue:e}}`);return!1}processNextQueue(){if(!this._processing){for(this._processing=!0;this._nextQueue.length;){const e=this._nextQueue.shift(),t=this.value;this._value=e;for(const s of this._subscriptions)s(e,t);this._complete&&(this._nextQueue=[])}this._processing=!1}}subscribeNext(e){return this._complete?{unsubscribe:F}:(this._subscriptions.add(e),{unsubscribe:()=>{this._subscriptions.delete(e)}})}subscribe(e){return this._complete||e(this.value),this.subscribeNext(e)}async when(e){return e(this.value)?this.value:this.whenNext(e)}async whenNext(e){return new Promise(t=>{const s=this.subscribeNext(i=>{(!e||e(i))&&(s.unsubscribe(),t(i))})})}complete(){this._complete||(this._complete=!0,this.completeDfd.resolve(),this.onComplete(this.value))}isComplete(){return this._complete}async whenComplete(){await this.completeDfd}reset(){this._complete&&(this._complete=!1,this.completeDfd=new w),this.next(this.initialValue)}toString(){return`${this.value}`}};n(k,"throwOnInvalid",!1);let E=k;const V=process.env.NODE_ENV==="development",y="@ACK",P="@PING",j=1e3,G=3,U=3e5;var A=(r=>(r[r.CONNECTING=0]="CONNECTING",r[r.OPEN=1]="OPEN",r[r.CLOSING=2]="CLOSING",r[r.CLOSED=3]="CLOSED",r))(A||{});const D=0;let R=1;function Q(r){const e=r.id?r.id:R++,t=r.meta??{};return{...r,id:e,meta:t}}function H(r){const e=r.meta??{};return{...r,meta:e,method:y}}function z(r){if(r&&typeof r.id=="number"&&typeof r.method=="string"&&Array.isArray(r.params)&&!("result"in r||r.error))return r}function B(r){if(r&&typeof r.id=="number"&&r.method===y&&("result"in r||r.error)&&!r.params)return r}function J(r){return`handle${r[0].toUpperCase()}${r.substring(1)}`}class I extends L{constructor(t,{timeout:s=j,pingAttempts:i=G,pingInterval:o=U,logger:h}={}){super();n(this,"requestDfds",new Map);n(this,"target");n(this,"timeout");n(this,"pingAttempts");n(this,"pingInterval");n(this,"logger");n(this,"_rtt",0);n(this,"readyState$");n(this,"handleCloseInternal",()=>{this.readyState$.next(3)});n(this,"closeEvent",{code:D,reason:""});n(this,"handleMessageInternal",async t=>{var o,h;if([2,3].includes(this.readyState))return;const s=B(t.data),i=z(t.data);if(s){const{id:l,method:d,error:c,result:g}=s;if(d===y){const f=this.requestDfds.get(l);f?(s.error?f.reject(c):f.resolve(g),this.requestDfds.delete(l)):(o=this.logger)==null||o.warn(`PostMessageAsyncAdapter::handleMessage: No dfd for id=${l}`)}}else if(i){let l;const{id:d,method:c,params:g}=i;if(c===P)l=this.handlePingInternal.bind(this);else{const v=J(c),C=this[v];typeof C=="function"&&(l=C.bind(this))}if(!l){(h=this.logger)==null||h.warn(`PostMessageAsyncAdapter::handleMessage: No handler for ${c}`,V?g:"");return}let f,_,p,Z={event:t,setTransfer:v=>p=v};try{f=await l(Z,...g)}catch(v){_=v}const ee=H({id:d,error:_,result:f,transfer:p,meta:{requestMethod:c}});this.postMessage(ee)}else{this.emit("messageerror",new Error("handleMessage failed: invalid data format"));return}});n(this,"isPinging",!1);this.target=t,this.timeout=s,this.pingAttempts=i,this.pingInterval=o,this.logger=h,this.readyState$=new E(0),this.readyState$.subscribeNext((l,d)=>{switch(l){case 1:this.emit("open");break;case 3:this.emit("close",this.closeEvent),this.closeEvent.code!==D&&this.emit("error",new Error(`closed with code ${this.closeEvent.code}: ${this.closeEvent.reason}`));break}this.emit("readystatechange",l)}),this.addTargetListeners()}get rtt(){return this._rtt}get readyState(){return this.readyState$.value}destroy(){this.readyState$.next(3),this.removeTargetListeners()}start(t){return t||this.sendPingInternal(),this}close(t=D,s=""){[0,1].includes(this.readyState)&&(this.closeEvent.code=t,this.closeEvent.reason=s,this.readyState$.next(2))}handlePingInternal(t,s){return this.readyState===0&&this.sendPingInternal(),s}async send(t,s,{timeout:i=this.timeout,transfer:o}={}){if(t===y)return;const h=new w;i>0&&setTimeout(()=>{h.reject(new Error(`${t} did not resolve after ${i}ms`))},i);const l=Q({method:t,params:s});this.requestDfds.set(l.id,h);let d=t===P||this.readyState===1;const c=()=>this.postMessage(l,o);if(d)c();else{const g=this.readyState$.when(p=>p===1).then(()=>!0),f=this.readyState$.when(p=>[3,2].includes(p)).then(()=>!1);Promise.race([g,f]).then(p=>{p?c():h.reject(new Error("Source not open"))})}return h}async sendPingInternal(){if(!this.isPinging&&[0,1].includes(this.readyState)){this.isPinging=!0;try{const t=Date.now();let s=this.pingAttempts,i=!1;for(;s-- >0&&!i;)try{const o=Date.now();await this.send(P,[{now:o}]),i=!0,this._rtt=Date.now()-o}catch{}if(i)this.readyState$.next(1);else{const o=Date.now()-t;this.emit("pingerror",new Error(`Ping timed out after ${o}ms`))}this.pingInterval&&setTimeout(()=>this.sendPingInternal(),this.pingInterval)}finally{this.isPinging=!1}}}}class K extends I{constructor(t,s,i){super(t,i);n(this,"origin");this.origin=s,this.readyState$.subscribeNext(o=>{o===3&&this.readyState$.next(0)})}addTargetListeners(){addEventListener("message",this.handleMessageInternal)}removeTargetListeners(){removeEventListener("message",this.handleMessageInternal)}postMessage(t,s){s?this.target.postMessage(t,this.origin,s):this.target.postMessage(t,this.origin)}}class N extends I{constructor(e,t){super(e,t),this.readyState$.subscribeNext(s=>{switch(s){case 3:this.removeTargetListeners();break}})}addTargetListeners(){this.target.addEventListener("message",this.handleMessageInternal),this.target.addEventListener("close",this.handleCloseInternal)}removeTargetListeners(){this.target.removeEventListener("message",this.handleMessageInternal),this.target.removeEventListener("close",this.handleCloseInternal)}start(e){return"start"in this.target&&this.target.start(),super.start(e)}close(e,t){super.close(e,t),"close"in this.target&&this.target.close()}postMessage(e,t){t?this.target.postMessage(e,t):this.target.postMessage(e)}}class X extends N{postMessage(e,t){super.postMessage(e,t==null?void 0:t.filter(s=>s instanceof MessagePort))}}const S=(r=new u)=>e=>async(...t)=>{let s;try{s=await r.requestLock();const i=await e(...t);return s(),i}catch(i){throw s==null||s(),i}},Y=r=>S()(r);a.AsyncLock=u,a.AsyncWorkerController=$,a.AsyncWorkerHandler=x,a.BasePostMessageAsyncAdapter=I,a.ConcurrentQueue=M,a.Deferred=w,a.ElectronPostMessageAsyncAdapter=X,a.Emitter=L,a.PostMessageAsyncAdapter=N,a.PostMessageReadyState=A,a.StateTransition=E,a.WindowPostMessageAsyncAdapter=K,a.createSeriesChannel=S,a.runInSeries=Y,Object.defineProperty(a,Symbol.toStringTag,{value:"Module"})});
