var N = Object.defineProperty;
var C = (r, e, t) => e in r ? N(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var n = (r, e, t) => (C(r, typeof e != "symbol" ? e + "" : e, t), t);
class x {
  constructor() {
    n(this, "_chain", Promise.resolve());
    n(this, "_unlocker", () => {
    });
    n(this, "_isLocked", !1);
  }
  /**
   * Requests the lock. Resolves with an unlock function once the lock is available and locked.
   *
   * const lock = new AsyncLock();
   * const unlock = await lock.requestLock();
   * ...
   * unlock(); // or: lock.unlock();
   */
  async requestLock() {
    let e;
    return this._isLocked = !0, this._chain = this._chain.then(
      () => new Promise((t) => {
        const s = () => {
          s === this._unlocker && (this._isLocked = !1, this._unlocker = () => {
          }, t());
        };
        this._unlocker = s, e(s);
      })
    ), new Promise((t) => {
      e = t;
    });
  }
  async whenUnlocked() {
    await this._chain;
  }
  /** Release the lock */
  unlock() {
    this._unlocker();
  }
  get isLocked() {
    return this._isLocked;
  }
}
const M = "__getStatsInternal__";
function A(r) {
  try {
    const e = r;
    return typeof e.data.id == "number" && typeof e.data.method == "string" && Array.isArray(e.data.params);
  } catch {
    return !1;
  }
}
function S(r) {
  if (A(r))
    return r.data;
}
function W(r) {
  try {
    const e = r;
    return typeof e.data.id == "number" && ("returnValue" in e.data || "error" in e.data);
  } catch {
    return !1;
  }
}
function b(r) {
  if (W(r))
    return r.data;
}
let O = 1;
class Y {
  constructor(e) {
    n(this, "worker");
    n(this, "workerUrl");
    n(this, "workerOptions");
    n(this, "onCreateWorker");
    n(this, "onTerminateWorker");
    n(this, "onMessageError");
    n(this, "requestFulfillerMap", {});
    n(this, "_stats", {
      pending: 0,
      completed: 0,
      totalDuration: 0
    });
    n(this, "handleMessage", (e) => {
      const t = b(e);
      if (t) {
        const { id: s, error: i, returnValue: o } = t, a = this.requestFulfillerMap[s];
        a && (i ? a.reject(i) : a.resolve(o), delete this.requestFulfillerMap[s]);
      }
    });
    n(this, "handleMessageError", (e) => {
      var t;
      (t = this.onMessageError) == null || t.call(this, e);
    });
    this.workerUrl = e.workerUrl, this.workerOptions = e.workerOptions, this.onCreateWorker = e.onCreateWorker, this.onMessageError = e.onMessageError, this.onTerminateWorker = e.onTerminateWorker;
  }
  getOrCreateWorker() {
    var e;
    return this.worker || (this.worker = new Worker(this.workerUrl, this.workerOptions), this.worker.addEventListener("message", this.handleMessage), this.worker.addEventListener("messageerror", this.handleMessageError), (e = this.onCreateWorker) == null || e.call(this, this.worker)), this.worker;
  }
  /** Start the worker manually, otherwise it is started on first exec */
  start() {
    this.getOrCreateWorker();
  }
  terminate() {
    var e;
    this.worker && (this.worker.removeEventListener("message", this.handleMessage), this.worker.removeEventListener("messageerror", this.handleMessageError), this.worker.terminate(), (e = this.onTerminateWorker) == null || e.call(this, this.worker), Object.values(this.requestFulfillerMap).forEach(({ reject: t }) => {
      t(new Error("Worker terminated"));
    }), this.requestFulfillerMap = {}, delete this.worker);
  }
  /** Execute a method in the worker with an array of parameters */
  async exec(e, t, s) {
    const i = Date.now();
    this._stats.pending++;
    const o = this.getOrCreateWorker(), a = O++, h = new Promise((u, d) => {
      this.requestFulfillerMap[a] = { resolve: u, reject: d };
    }), c = {
      id: a,
      method: e,
      params: t
    };
    s ? o.postMessage(c, s) : o.postMessage(c);
    const l = () => {
      this._stats.totalDuration += Date.now() - i, this._stats.pending--, this._stats.completed++;
    };
    return h.then(l, l), h;
  }
  async getStats() {
    const e = await this.exec(M, []), t = this._stats.totalDuration / this._stats.completed;
    return {
      ...this._stats,
      avgDuration: t,
      avgLatency: t - e.avgDuration,
      totalWorkerDuration: e.totalDuration,
      diffDuration: this._stats.totalDuration - e.totalDuration
    };
  }
}
class Z {
  constructor(e, t = {}) {
    n(this, "handlerMap");
    n(this, "onMessageError");
    n(this, "_stats", {
      pending: 0,
      completed: 0,
      totalDuration: 0
    });
    n(this, "handleMessage", async (e) => {
      const t = S(e);
      if (!t)
        return;
      this._stats.pending++;
      const s = Date.now(), { id: i, method: o, params: a } = t, h = this.handlerMap[o];
      let c, l, u;
      const d = (g) => u = g;
      if (h)
        try {
          c = await h(...a, d);
        } catch (g) {
          l = g;
        }
      else
        l = new Error(`No handler for type ${o}`);
      const p = {
        id: i,
        returnValue: c,
        error: l
      };
      this._stats.pending--, this._stats.completed++, this._stats.totalDuration += Date.now() - s, u ? postMessage(p, u) : postMessage(p);
    });
    n(this, "handleError", (e) => {
      var t;
      (t = this.onMessageError) == null || t.call(this, e);
    });
    n(this, "getStats", () => ({
      ...this._stats,
      avgDuration: this._stats.totalDuration / this._stats.completed
    }));
    if (typeof window < "u" && window.window === window)
      throw new Error("AsyncWorkerWorker must run in a worker");
    this.handlerMap = e, this.handlerMap[M] = this.getStats, this.onMessageError = t.onMessageError, addEventListener("message", this.handleMessage), addEventListener("messageerror", this.handleError);
  }
  terminate() {
    removeEventListener("message", this.handleMessage), removeEventListener("messageerror", this.handleError);
  }
}
class P {
  constructor(e) {
    n(this, "inProgressWorkloadPromises", []);
    n(this, "enqueuedWorkloads", []);
    this.concurrency = e;
  }
  static processWorkloads(e, t) {
    const s = new P(e);
    for (const i of t)
      s.enqueue(i);
    return s.process();
  }
  enqueue(e) {
    this.enqueuedWorkloads.push(e);
  }
  async process() {
    const e = [];
    for (const s of this.enqueuedWorkloads) {
      const i = this.run(s);
      if (e.push(i), this.inProgressWorkloadPromises.push(i), this.inProgressWorkloadPromises.length >= this.concurrency)
        try {
          await Promise.race(this.inProgressWorkloadPromises);
        } catch {
        }
    }
    const t = [];
    for (const s of e)
      try {
        const i = await s;
        t.push({
          status: "fulfilled",
          value: i
        });
      } catch (i) {
        t.push({
          status: "rejected",
          reason: i
        });
      }
    return t;
  }
  run(e) {
    const t = e(), s = () => this.dequeueInProgressWorkloadPromise(t);
    return t.then(s).catch(s), t;
  }
  dequeueInProgressWorkloadPromise(e) {
    const t = this.inProgressWorkloadPromises.findIndex((s) => s === e);
    this.inProgressWorkloadPromises.splice(t, 1);
  }
}
class f {
  constructor() {
    n(this, "_resolver");
    n(this, "_promise");
    n(this, "_state", "PENDING");
    n(this, "resolve", (e) => {
      this._state === "PENDING" && (this._state = "FULFILLED", this._resolver({ value: e }));
    });
    n(this, "reject", (e) => {
      this._state === "PENDING" && (this._state = "REJECTED", this._resolver({ reason: e }));
    });
    n(this, "then", async (e, t) => {
      const { value: s, reason: i } = await this._promise;
      if (i)
        if (t)
          t(i);
        else
          throw i;
      else
        return e == null || e(s), s;
    });
    n(this, "catch", (e) => this.then(void 0, e));
    this._promise = new Promise((e) => {
      this._resolver = e;
    });
  }
  /* Create a resolved Deferred */
  static resolve(e) {
    const t = new f();
    return t.resolve(e), t;
  }
  /* Create a rejected Deferred */
  static reject(e) {
    const t = new f();
    return t.reject(e), t;
  }
  /* Create a Deferred that resolves/rejects when the given promises does the same */
  static fromPromise(e) {
    const t = new f();
    return e.then(
      (s) => t.resolve(s),
      (s) => t.reject(s)
    ), t;
  }
  get state() {
    return this._state;
  }
  get isPending() {
    return this._state === "PENDING";
  }
  get isFulfilled() {
    return this._state === "FULFILLED";
  }
  get isRejected() {
    return this._state === "REJECTED";
  }
}
class T {
  constructor() {
    n(this, "_listeners", {});
    n(this, "throwOnEmitterError", !1);
  }
  /** Emit an event to the listeners on eventName */
  emit(e, ...t) {
    const s = this._listeners[e];
    return s ? (s.forEach((i) => {
      try {
        const o = i(t[0]);
        o && "then" in o && typeof o.then == "function" && o.then(
          (a) => a,
          (a) => {
            if (this.throwOnEmitterError)
              throw a;
          }
        );
      } catch (o) {
        if (this.throwOnEmitterError)
          throw o;
      }
    }), s.size) : 0;
  }
  /** Call the callback function whenever a future event is emitted */
  on(e, t) {
    return (this._listeners[e] || (this._listeners[e] = /* @__PURE__ */ new Set())).add(t), () => this.off(e, t);
  }
  once(e, t) {
    if (!t)
      return new Promise((i) => this.once(e, i));
    const s = this.on(e, (i) => {
      s(), t(i);
    });
    return s;
  }
  /** Remove an event listener */
  off(e, t) {
    var s;
    return !!((s = this._listeners[e]) != null && s.delete(t));
  }
  /** @returns an array of all the current listeners for the given eventName */
  listeners(e) {
    return Array.from(this._listeners[e] ?? []);
  }
  /** @returns the count of all the current listeners for the given eventName */
  listenerCount(e) {
    var t;
    return ((t = this._listeners[e]) == null ? void 0 : t.size) ?? 0;
  }
}
const q = () => {
}, _ = class _ {
  constructor(e, t = () => !0) {
    n(this, "_complete", !1);
    n(this, "_value");
    // store future values in case the state is modified by a subscriber
    n(this, "_nextQueue", []);
    n(this, "_processing", !1);
    n(this, "_subscriptions", /* @__PURE__ */ new Set());
    n(this, "completeDfd", new f());
    this.initialValue = e, this.isNextValueValid = t, this._value = e;
  }
  get value() {
    return this._value;
  }
  /**
   * Optional callback to listen for invalid state changes. \
   * Arguments to callback: (invalidValue, currentValue). \
   * Useful for debugging.
   */
  onInvalid(e, t) {
  }
  onComplete(e) {
  }
  /** returns true if the state transition is successful */
  next(e) {
    if (this._complete)
      return !1;
    const t = this.value;
    if (t === e)
      return !1;
    if (this.isNextValueValid(t, e))
      return this._nextQueue.push(e), this.processNextQueue(), !0;
    if (this.onInvalid(e, this.value), _.throwOnInvalid)
      throw new Error(
        `StateTransition::next: Invalid state change: ${{ currentValue: this._value, nextValue: e }}`
      );
    return !1;
  }
  processNextQueue() {
    if (!this._processing) {
      for (this._processing = !0; this._nextQueue.length; ) {
        const e = this._nextQueue.shift(), t = this.value;
        this._value = e;
        for (const s of this._subscriptions)
          s(e, t);
        this._complete && (this._nextQueue = []);
      }
      this._processing = !1;
    }
  }
  /** Subscribe, but skip the current value and wait for the next transition */
  subscribeNext(e) {
    return this._complete ? { unsubscribe: q } : (this._subscriptions.add(e), {
      unsubscribe: () => {
        this._subscriptions.delete(e);
      }
    });
  }
  /** Subscribe, and get called immediately with the current value */
  subscribe(e) {
    return this._complete || e(this.value), this.subscribeNext(e);
  }
  async when(e) {
    return e(this.value) ? this.value : this.whenNext(e);
  }
  async whenNext(e) {
    return new Promise((t) => {
      const s = this.subscribeNext((i) => {
        (!e || e(i)) && (s.unsubscribe(), t(i));
      });
    });
  }
  /** Prevents future state transitions */
  complete() {
    this._complete || (this._complete = !0, this.completeDfd.resolve(), this.onComplete(this.value));
  }
  isComplete() {
    return this._complete;
  }
  async whenComplete() {
    await this.completeDfd;
  }
  reset() {
    this._complete && (this._complete = !1, this.completeDfd = new f()), this.next(this.initialValue);
  }
  toString() {
    return `${this.value}`;
  }
};
n(_, "throwOnInvalid", !1);
let k = _;
const $ = process.env.NODE_ENV === "development", w = "@ACK", v = "@PING", F = 1e3, V = 3, G = 3e5;
var U = /* @__PURE__ */ ((r) => (r[r.CONNECTING = 0] = "CONNECTING", r[r.OPEN = 1] = "OPEN", r[r.CLOSING = 2] = "CLOSING", r[r.CLOSED = 3] = "CLOSED", r))(U || {});
const E = 0;
let j = 1;
function R(r) {
  const e = r.id ? r.id : j++, t = r.meta ?? {};
  return { ...r, id: e, meta: t };
}
function Q(r) {
  const e = r.meta ?? {};
  return { ...r, meta: e, method: w };
}
function z(r) {
  if (r && typeof r.id == "number" && typeof r.method == "string" && Array.isArray(r.params) && // not response
  !("result" in r || r.error))
    return r;
}
function H(r) {
  if (r && typeof r.id == "number" && r.method === w && ("result" in r || r.error) && // not request
  !r.params)
    return r;
}
function J(r) {
  return `handle${r[0].toUpperCase()}${r.substring(1)}`;
}
class D extends T {
  constructor(t, {
    timeout: s = F,
    pingAttempts: i = V,
    pingInterval: o = G,
    logger: a
  } = {}) {
    super();
    /** map of outstanding requests awaiting a response */
    n(this, "requestDfds", /* @__PURE__ */ new Map());
    n(this, "target");
    /** Throw an error if we don't get a response in time */
    n(this, "timeout");
    n(this, "pingAttempts");
    n(this, "pingInterval");
    n(this, "logger");
    /** latest round trip time, as measured by pings */
    n(this, "_rtt", 0);
    n(this, "readyState$");
    n(this, "handleCloseInternal", () => {
      this.readyState$.next(
        3
        /* CLOSED */
      );
    });
    n(this, "closeEvent", {
      code: E,
      reason: ""
    });
    n(this, "handleMessageInternal", async (t) => {
      var o, a;
      if ([
        2,
        3
        /* CLOSED */
      ].includes(this.readyState))
        return;
      const s = H(t.data), i = z(t.data);
      if (s) {
        const { id: h, method: c, error: l, result: u } = s;
        if (c === w) {
          const d = this.requestDfds.get(h);
          d ? (s.error ? d.reject(l) : d.resolve(u), this.requestDfds.delete(h)) : (o = this.logger) == null || o.warn(`PostMessageAsyncAdapter::handleMessage: No dfd for id=${h}`);
        }
      } else if (i) {
        let h;
        const { id: c, method: l, params: u } = i;
        if (l === v)
          h = this.handlePingInternal.bind(this);
        else {
          const m = J(l), y = this[m];
          typeof y == "function" && (h = y.bind(this));
        }
        if (!h) {
          (a = this.logger) == null || a.warn(
            `PostMessageAsyncAdapter::handleMessage: No handler for ${l}`,
            $ ? u : ""
          );
          return;
        }
        let d, p, g, I = {
          event: t,
          setTransfer: (m) => g = m
        };
        try {
          d = await h(I, ...u);
        } catch (m) {
          p = m;
        }
        const L = Q({
          id: c,
          error: p,
          result: d,
          transfer: g,
          meta: { requestMethod: l }
        });
        this.postMessage(L);
      } else {
        this.emit("messageerror", new Error("handleMessage failed: invalid data format"));
        return;
      }
    });
    n(this, "isPinging", !1);
    this.target = t, this.timeout = s, this.pingAttempts = i, this.pingInterval = o, this.logger = a, this.readyState$ = new k(
      0
      /* CONNECTING */
    ), this.readyState$.subscribeNext((h, c) => {
      switch (h) {
        case 1:
          this.emit("open");
          break;
        case 3:
          this.emit("close", this.closeEvent), this.closeEvent.code !== E && this.emit(
            "error",
            new Error(`closed with code ${this.closeEvent.code}: ${this.closeEvent.reason}`)
          );
          break;
      }
      this.emit("readystatechange", h);
    }), this.addTargetListeners();
  }
  get rtt() {
    return this._rtt;
  }
  get readyState() {
    return this.readyState$.value;
  }
  destroy() {
    this.readyState$.next(
      3
      /* CLOSED */
    ), this.removeTargetListeners();
  }
  start(t) {
    return t || this.sendPingInternal(), this;
  }
  close(t = E, s = "") {
    [
      0,
      1
      /* OPEN */
    ].includes(this.readyState) && (this.closeEvent.code = t, this.closeEvent.reason = s, this.readyState$.next(
      2
      /* CLOSING */
    ));
  }
  // handles @PING, named suffix in case users want to have their own external method named ping
  handlePingInternal(t, s) {
    return this.readyState === 0 && this.sendPingInternal(), s;
  }
  /** @throws if source closes or no response after timeout */
  async send(t, s, { timeout: i = this.timeout, transfer: o } = {}) {
    if (t === w)
      return;
    const a = new f();
    i > 0 && setTimeout(() => {
      a.reject(new Error(`${t} did not resolve after ${i}ms`));
    }, i);
    const h = R({ method: t, params: s });
    this.requestDfds.set(h.id, a);
    let c = t === v || this.readyState === 1;
    const l = () => this.postMessage(h, o);
    if (c)
      l();
    else {
      const u = this.readyState$.when(
        (g) => g === 1
        /* OPEN */
      ).then(() => !0), d = this.readyState$.when(
        (g) => [
          3,
          2
          /* CLOSING */
        ].includes(g)
      ).then(() => !1);
      Promise.race([u, d]).then((g) => {
        g ? l() : a.reject(new Error("Source not open"));
      });
    }
    return a;
  }
  async sendPingInternal() {
    if (!this.isPinging && [
      0,
      1
      /* OPEN */
    ].includes(this.readyState)) {
      this.isPinging = !0;
      try {
        const t = Date.now();
        let s = this.pingAttempts, i = !1;
        for (; s-- > 0 && !i; )
          try {
            const o = Date.now();
            await this.send(v, [{ now: o }]), i = !0, this._rtt = Date.now() - o;
          } catch {
          }
        if (i)
          this.readyState$.next(
            1
            /* OPEN */
          );
        else {
          const o = Date.now() - t;
          this.emit("pingerror", new Error(`Ping timed out after ${o}ms`));
        }
        this.pingInterval && setTimeout(() => this.sendPingInternal(), this.pingInterval);
      } finally {
        this.isPinging = !1;
      }
    }
  }
}
class ee extends D {
  constructor(t, s, i) {
    super(t, i);
    n(this, "origin");
    this.origin = s, this.readyState$.subscribeNext((o) => {
      o === 3 && this.readyState$.next(
        0
        /* CONNECTING */
      );
    });
  }
  addTargetListeners() {
    addEventListener("message", this.handleMessageInternal);
  }
  removeTargetListeners() {
    removeEventListener("message", this.handleMessageInternal);
  }
  postMessage(t, s) {
    s ? this.target.postMessage(t, this.origin, s) : this.target.postMessage(t, this.origin);
  }
}
class K extends D {
  constructor(e, t) {
    super(e, t), this.readyState$.subscribeNext((s) => {
      switch (s) {
        case 3:
          this.removeTargetListeners();
          break;
      }
    });
  }
  addTargetListeners() {
    this.target.addEventListener("message", this.handleMessageInternal), this.target.addEventListener("close", this.handleCloseInternal);
  }
  removeTargetListeners() {
    this.target.removeEventListener("message", this.handleMessageInternal), this.target.removeEventListener("close", this.handleCloseInternal);
  }
  start(e) {
    return "start" in this.target && this.target.start(), super.start(e);
  }
  close(e, t) {
    super.close(e, t), "close" in this.target && this.target.close();
  }
  postMessage(e, t) {
    t ? this.target.postMessage(e, t) : this.target.postMessage(e);
  }
}
class te extends K {
  postMessage(e, t) {
    super.postMessage(
      e,
      t == null ? void 0 : t.filter((s) => s instanceof MessagePort)
    );
  }
}
const B = (r = new x()) => (e) => async (...t) => {
  let s;
  try {
    s = await r.requestLock();
    const i = await e(...t);
    return s(), i;
  } catch (i) {
    throw s == null || s(), i;
  }
}, se = (r) => B()(r);
export {
  x as AsyncLock,
  Y as AsyncWorkerController,
  Z as AsyncWorkerHandler,
  D as BasePostMessageAsyncAdapter,
  P as ConcurrentQueue,
  f as Deferred,
  te as ElectronPostMessageAsyncAdapter,
  T as Emitter,
  K as PostMessageAsyncAdapter,
  U as PostMessageReadyState,
  k as StateTransition,
  ee as WindowPostMessageAsyncAdapter,
  B as createSeriesChannel,
  se as runInSeries
};
