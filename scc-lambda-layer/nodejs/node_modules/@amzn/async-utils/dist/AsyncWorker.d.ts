type AnyFunction = (...args: any[]) => any;
type SetTransfer = (t: Transferable[]) => void;
type HandlerFn<F extends AnyFunction> = (...args: [...Parameters<F>, SetTransfer]) => Promise<ReturnType<F>> | ReturnType<F>;
type WorkerHandlerMap<T extends AnyRecord> = {
    [K in keyof T]: T[K] extends AnyFunction ? HandlerFn<T[K]> : never;
};
type AsyncWorkerControllerOptions = {
    workerUrl: string | URL;
    workerOptions?: WorkerOptions;
    onCreateWorker?: (worker: Worker) => void;
    onMessageError?: (event: MessageEvent) => void;
    onTerminateWorker?: (worker: Worker) => void;
};
type AsyncWorkerHandlerOptions = {
    onMessageError?: (event: MessageEvent) => void;
};
type AnyRecord = Record<string, any>;
type MethodKey<T extends AnyRecord> = string & keyof T;
interface AsyncExec<T extends AnyRecord> {
    exec<K extends MethodKey<T>>(methodName: K, args: Parameters<T[K]>): Promise<ReturnType<T[K]>>;
}
/**
 * Instantiate the controller in the main thread, which will create a worker and
 * managed all communication between the worker and main. Data can be transferred
 * between the main thread and the worker.
 */
export declare class AsyncWorkerController<ExecMap extends AnyRecord> implements AsyncExec<ExecMap> {
    private worker?;
    private workerUrl;
    private workerOptions?;
    private onCreateWorker?;
    private onTerminateWorker?;
    private onMessageError?;
    private requestFulfillerMap;
    private _stats;
    constructor(options: AsyncWorkerControllerOptions);
    private getOrCreateWorker;
    /** Start the worker manually, otherwise it is started on first exec */
    start(): void;
    terminate(): void;
    /** Execute a method in the worker with an array of parameters */
    exec<K extends MethodKey<ExecMap>>(method: K, params: Parameters<ExecMap[K]>, transfer?: Transferable[]): Promise<ReturnType<ExecMap[K]>>;
    private handleMessage;
    private handleMessageError;
    getStats(): Promise<{
        avgDuration: number;
        avgLatency: number;
        totalWorkerDuration: any;
        diffDuration: number;
        pending: number;
        completed: number;
        totalDuration: number;
    }>;
}
/**
 * Instantiate the handler in the worker
 */
export declare class AsyncWorkerHandler<T extends AnyRecord> {
    private handlerMap;
    private onMessageError?;
    private _stats;
    constructor(handlerMap: WorkerHandlerMap<T>, options?: AsyncWorkerHandlerOptions);
    terminate(): void;
    private handleMessage;
    private handleError;
    getStats: () => {
        avgDuration: number;
        pending: number;
        completed: number;
        totalDuration: number;
    };
}
export {};
