export type OptionalArgTuple<T> = T extends undefined ? [] : [T];
export type Unsubscriber = () => void;
type EventMap = Record<string, any>;
type EventKey<T extends EventMap> = string & keyof T;
type EventReceiver<T> = (event: T) => any;
interface IEmitter<T extends EventMap> {
    on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): Unsubscriber;
    once<K extends EventKey<T>>(eventName: K): Promise<T[K]>;
    once<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): Unsubscriber;
    emit<K extends EventKey<T>>(eventName: K, ...event: OptionalArgTuple<T[K]>): number;
}
/**
 * Generic emitter class that supplies types through an interface of key-value pairs
 * where key = event name and value = event data payload
 */
export declare class Emitter<T extends EventMap = {}> implements IEmitter<T> {
    private _listeners;
    protected throwOnEmitterError: boolean;
    /** Emit an event to the listeners on eventName */
    emit<K extends EventKey<T>>(eventName: K, ...event: OptionalArgTuple<T[K]>): number;
    /** Call the callback function whenever a future event is emitted */
    on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): Unsubscriber;
    /** Listen for the event once and then remove the listener */
    once<K extends EventKey<T>>(eventName: K): Promise<T[K]>;
    once<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): Unsubscriber;
    /** Remove an event listener */
    off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): boolean;
    /** @returns an array of all the current listeners for the given eventName */
    listeners<K extends EventKey<T>>(eventName: K): EventReceiver<T[K]>[];
    /** @returns the count of all the current listeners for the given eventName */
    listenerCount<K extends EventKey<T>>(eventName: K): number;
}
export {};
