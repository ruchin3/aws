import { Emitter } from './Emitter';
import { StateTransition } from './StateTransition';
type EventMap = Record<string, [arg: any, returnValue: any]>;
type EventKey<T extends EventMap> = string & keyof T;
type AnyFunction = (...args: any[]) => any;
export type PostMessageEvent = MessageEvent<any>;
export type SameOriginPostMessageTarget = MessagePort | Worker | BroadcastChannel;
export type AnyPostMessageTarget = Window | SameOriginPostMessageTarget;
export type TransferableItem = Transferable;
export type PostMessageResult<Result = any> = {
    result: Awaited<Result>;
    transfer?: TransferableItem[];
};
export declare enum PostMessageReadyState {
    CONNECTING = 0,
    OPEN = 1,
    CLOSING = 2,
    CLOSED = 3
}
type PostMessageCloseEvent = {
    /** code = 0 is considered normal, all others emit an error */
    code: number;
    reason: string;
};
export type PostMessageAsyncAdapterConstructorOptions = Partial<{
    timeout: number;
    pingAttempts: number;
    pingInterval: number;
    origin: string;
    logger?: ILogger;
}>;
type PostMessageEvents = {
    open: void;
    close: PostMessageCloseEvent;
    messageerror: Error;
    pingerror: Error;
    error: Error;
    readystatechange: PostMessageReadyState;
};
type PostMessageSendOptions = Partial<{
    timeout: number;
    transfer: TransferableItem[];
}>;
type SetTransfer = (transfer: TransferableItem[] | undefined) => void;
export type PostMessageAsyncHandlerApi = {
    event: MessageEvent;
    setTransfer: SetTransfer;
};
/**
 * Returns a tuple of the arguments and return type.
 * Promises are unwrapped from the return type
 * @example
 * input: function getUser(id: string): Promise<User>
 * output: [[string], User]
 */
type FunctionToArgumentsReturnTypeTuple<F extends (...args: any[]) => any> = [
    Parameters<F>,
    Awaited<ReturnType<F>>
];
/**
 * Maps an API method interface to PostMessage Handler keys and tuples.
 * @example:
 * input: { getUser(id: string): Promise<User> }
 * output: { getUser: [id, User] }
 */
export type ToMessageSenders<T extends any> = {
    [K in keyof T]: T[K] extends AnyFunction ? FunctionToArgumentsReturnTypeTuple<T[K]> : never;
};
type PrependMessageEventArgument<Fn extends AnyFunction> = (...args: [...[api: PostMessageAsyncHandlerApi], ...Parameters<Fn>]) => ReturnType<Fn>;
type MapReturnTypeToMessageResult<Fn extends AnyFunction> = (...args: Parameters<Fn>) => Awaited<ReturnType<Fn>> extends void ? Promise<void> | void | PostMessageResult<ReturnType<Fn>> | Promise<PostMessageResult<ReturnType<Fn>>> : ReturnType<Fn> | Promise<ReturnType<Fn>>;
/**
 * Maps all props to have a "handle" prefix
 * @example
 * input: { getUser(id: string): Promise<User>; setUser(user: User): Promise<void> }
 * output: { handleGetUser(id: string): Promise<User>; handleGetUser(user: User): Promise<void> }
 */
export type ToMessageHandlers<T> = {
    [K in keyof T as `handle${Capitalize<string & K>}`]: T[K] extends AnyFunction ? MapReturnTypeToMessageResult<PrependMessageEventArgument<T[K]>> : T[K];
};
/** Wrapper to allow you to build async APIs on top of postMessage/ports */
export declare abstract class BasePostMessageAsyncAdapter<Target extends AnyPostMessageTarget, Senders extends EventMap> extends Emitter<PostMessageEvents> {
    /** map of outstanding requests awaiting a response */
    private requestDfds;
    readonly target: Target;
    /** Throw an error if we don't get a response in time */
    readonly timeout: number;
    readonly pingAttempts: number;
    readonly pingInterval: number;
    readonly logger?: ILogger;
    /** latest round trip time, as measured by pings */
    private _rtt;
    get rtt(): number;
    protected readonly readyState$: StateTransition<PostMessageReadyState>;
    get readyState(): PostMessageReadyState;
    constructor(target: Target, { timeout, pingAttempts, pingInterval, logger, }?: PostMessageAsyncAdapterConstructorOptions);
    protected abstract addTargetListeners(): void;
    protected abstract removeTargetListeners(): void;
    destroy(): void;
    start(waitForIncomingPing?: boolean): this;
    protected handleCloseInternal: () => void;
    private closeEvent;
    close(code?: number, reason?: string): void;
    protected abstract postMessage(message: Record<string, unknown>, transfer?: TransferableItem[]): void;
    private handlePingInternal;
    protected handleMessageInternal: (e: MessageEvent) => Promise<void>;
    /** @throws if source closes or no response after timeout */
    send<K extends EventKey<Senders>>(method: K, params: Senders[K][0], { timeout, transfer }?: PostMessageSendOptions): Promise<Senders[K][1]>;
    private isPinging;
    private sendPingInternal;
}
/**
 * Adapter for windows and iframes, which support cross-origin and origins
 */
export declare class WindowPostMessageAsyncAdapter<Senders extends EventMap> extends BasePostMessageAsyncAdapter<Window, Senders> {
    readonly origin: string;
    constructor(target: Window, origin: string, options?: PostMessageAsyncAdapterConstructorOptions);
    protected addTargetListeners(): void;
    protected removeTargetListeners(): void;
    protected postMessage(message: Record<string, unknown>, transfer?: TransferableItem[]): void;
}
/**
 * Adapter for same-origin postMessage objects, such as MessagePort, Worker, and BroadcastChannel
 */
export declare class PostMessageAsyncAdapter<Senders extends EventMap> extends BasePostMessageAsyncAdapter<SameOriginPostMessageTarget, Senders> {
    constructor(target: SameOriginPostMessageTarget, options?: PostMessageAsyncAdapterConstructorOptions);
    protected addTargetListeners(): void;
    protected removeTargetListeners(): void;
    start(waitForIncomingPing?: boolean | undefined): this;
    close(code?: number, reason?: string): void;
    protected postMessage(message: Record<string, unknown>, transfer?: TransferableItem[]): void;
}
/**
 * Same as PostMessageAsyncAdapter, but handles behavior of Electron's MessagePorts
 * https://www.electronjs.org/docs/latest/tutorial/message-ports
 */
export declare class ElectronPostMessageAsyncAdapter<Senders extends EventMap> extends PostMessageAsyncAdapter<Senders> {
    protected postMessage(message: Record<string, unknown>, transfer?: TransferableItem[]): void;
}
export {};
