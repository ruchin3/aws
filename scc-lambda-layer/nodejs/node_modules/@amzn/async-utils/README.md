# AsyncUtilsTS - `@amzn/async-utils`

## AsyncLock

```typescript
// A lock to prevent the camera preview and camera in app from
// attempting to use the camera simultaneously. This is an async
// approach instead of booleans, e.g., isCameraInUse.
const cameraLock = new AsyncLock();

async getCamera() {
  const unlock = await cameraLock.requestLock();

  return {
    camera: streamDataFromCamera(),
    done: () => unlock()
  }
}

async useCameraPreview() {
  const { camera, done } = await getCamera();
  videoPreviewEl.src = camera.src;
  // ...
  done();
}

async useCameraInApp() {
  const { camera, done } = await getCamera();
  mainVideoEl.src = camera.src;
  // ...
  done();
}
```

## AsyncWorker

Proxies communication between main and worker with type checking

```typescript
// Shared type for the available methods in the worker
type Math = {
  add(a: number, b: number): number;
  double(a: number): number;
}

// in main thread
const controller = new AsyncWorkerController<Math>({
  workerUrl: './path/to/worker.ts',
  workerOptions: { type: 'module' }
});
await controller.exec('add', [2, 3]); // 5
await controller.exec('double', [4]); // 8

// in worker.ts
const handler = new AsyncWorkerHandler<Math>({
  add: (a, b) => a + b,
  double: (a) => a + a,
});
```

## ConcurrentQueue

Process a queue of workloads in parallel with a specified amount of concurrency.

```typescript
const cq = new ConcurrentQueue(3);
cq.enqueue(async () => {
  return await fetch('/cat/image/1');
});
cq.enqueue(async () => {
  return await fetch('/cat/image/2');
});
cq.enqueue(async () => {
  return await fetch('/cat/image/3');
});
cq.enqueue(async () => {
  return await fetch('/cat/image/4/err');
});
cq.enqueue(async () => {
  return await fetch('/cat/image/5');
});
const result = await cq.process();
console.log(result.results); // -> [{id: 1}, {id: 2}, {id: 3}, {id: 5}]
console.log(result.errors); // -> [{error: 404}]
```

## Deferred

Create externally-resolvable promises.

```typescript
class App {
  private appReady = new Deferred<void>();

  init() {
    // do init stuff
    this.appReady.resolve();
  }

  async whenReady() {
    await this.appReady;
  }
}

const app = new App();
app.init();
app.whenReady().then(() => console.log('ready to go!');
```

## Emitter

Create type-safe emitter functions.

```typescript
class FetchResource extends Emitter<{
  response: Response;
  error: any;
}> {
  constructor(url: string) {
    super();

    const req = fetch(url);
    req.then(
      (res) => this.emit('response', res),
      (err) => this.emit('error', err)
    );

    // TS error: number is not of type Response
    this.emit('response', 7);
  }
}

const getResource = new FetchResource('http://example.com');
getResource.on('response', (res) => {
  // res is of type Response
  res.json().then(json => console.dir(json));
});
getResource.on('error', (err) => {
  // err is of type any
  console.error(err);
});
getResource.once('response', (res) => {
  // get the next response, and Unsubscribe
});
// get the next response as a promise
const res = await getResource.once('response');
```

## Run async functions in series

### runInSeries

Prevent an async function from overlapping itself

```typescript
const print = async () => {
  log('A');
  await delay();
  log('B');
  await delay();
  log('C');
}

// calling without awaiting, these will overlap
print();
print();
// output: A A B B C C

const printInSeries = runInSeries(print);

// Even without awaiting, these won't overlap
printInSeries(); printInSeries();
// output: A B C A B C
```

### createSeriesChannel

Create a channel that can be applied to multiple functions

```typescript
const print123 = async () => {
  log('1');
  await delay();
  log('2');
  await delay();
  log('3');
};
const printABC = async () => {
  log('A');
  await delay();
  log('B');
  await delay();
  log('C');
};

print123();
printABC();
// output: 1 A 2 B 3 C

// Create a series "channel" that multiple functions can share
const runInChannel = createSeriesChannel();
const print123Series = runInChannel(print123);
const printABCSeries = runInChannel(printABC);
print123Series();
printABCSeries();
// output: 1 2 3 A B C
```

## StateTransition

Create a piece of state that can be subscribed to via callbacks and promises

```typescript
enum AppStates {
  Loading,
  Ready,
  Error,
}

const appState = new StateTransition<AppStates>(
  // initial state
  AppStates.Loading,
  // guard our transitions
  (state, nextState) => {
  switch (state) {
    case AppStates.Loading:
      return [AppStates.Ready, AppStates.Error].includes(nextState);
    case AppStates.Ready:
      return nextState === AppStates.Error;
    case AppStates.Error:
      return false; // Can never leave error state
  }
});

const runAtReady = async () => {
  await appState.when((state) => state === AppStates.Ready)
  startLoggingService();
  gotoHomeScreen();
}

appState.subscribe((state) => {
  if (state === AppStates.Error) {
    console.error('App has failed. Please try again.');
  }
});

appState.subscribe((state, previousState) => {
  console.log('appState went from:', previousState, 'to:', state);
});
```

## PostMessageAsyncAdapter

Adapter to provide type safe, async workflows for the `postMessage`+`addEventListener` interface,
such as [windows/iframes](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage),
[Workers](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage),
[MessagePort](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/postMessage)
(including [Electron MessagePorts](https://www.electronjs.org/docs/latest/tutorial/message-ports)).

See test file for example.

---

The NPM package name should always start with `@amzn/` to cleanly separate from
public packages, avoid accidental publish to public repository, and allow
publishing to CodeArtifact.

The package is built with
[NpmPrettyMuch](https://w.amazon.com/bin/view/NpmPrettyMuch/GettingStarted/v1)
and allows using internal (first-party) dependencies as well as external
npmjs.com packages.

Add registry dependencies with `brazil-build install` exactly the same as [`npm
install`](https://docs.npmjs.com/cli-commands/install.html). You can check
latest state of external dependencies on https://npmpm.corp.amazon.com/
Important: always use `brazil-build` wrapper for npm, using `npm` directly will
use the public registry instead of the internal registry.

Add brazil packages that build npm packages to the `dependencies` or
`test-dependencies` sections in the Config file,  then add a `*` dependency or
devDependencies to package.json. You should match `test-dependencies` with
`devDependencies`, and normal `dependencies` with `dependencies`.

NpmPrettyMuch 1.0 has special behavior for running tests during build. The
option `"runTest": "never"` disabled this and instead tests are wired up in
`prepublishOnly`. NpmPrettyMuch will invoke `prepublishOnly` and everything can
configured in there the [same as with external
npm](https://docs.npmjs.com/misc/scripts). Files to published are configured
using [`files` in
`package.json`](https://docs.npmjs.com/configuring-npm/package-json.html#files).
The option `ciBuild` uses [`npm
ci`](https://docs.npmjs.com/cli-commands/ci.html) instead of `npm install` and
results in faster install times and guarantees all of your dependencies are
locked appropriately.
