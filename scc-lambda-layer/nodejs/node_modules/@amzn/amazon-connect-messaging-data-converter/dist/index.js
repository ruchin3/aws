'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function isConnectItem(obj) {
    try {
        return "Type" in obj;
    }
    catch (e) {
        return false;
    }
}
function isValidAttachmentsSize(attachments = [], maxFileSize) {
    return attachments.every((arg) => {
        return arg.size <= maxFileSize;
    });
}

class ValidationException extends Error {
    constructor(message = ValidationException.DEFAULT_MESSAGE) {
        super(message);
    }
}
ValidationException.DEFAULT_MESSAGE = "Validation exception";

class MessagingDataConverterBase {
    static convert(sourceObj, attachmentArgs) {
        if (isConnectItem(sourceObj)) {
            if (this.satisfiesPlatformConstraints(sourceObj, attachmentArgs)) {
                return this.convertConnectChatToPlatform(sourceObj, attachmentArgs);
            }
            else {
                // TODO: emit metrics
                throw new ValidationException("Platform constraints are not met");
            }
        }
        else {
            if (this.satisfiesConnectConstraints(sourceObj, attachmentArgs)) {
                return this.convertPlatformToConnectChat(sourceObj, attachmentArgs);
            }
            else {
                // TODO: emit metrics
                throw new ValidationException("Connect constraints are not met");
            }
        }
    }
    static convertPlatformToConnectChat(obj, _attachmentArgs) {
        throw new Error(`Subclasses must implement the platformToConnectChat method to translate ${obj}`);
    }
    static convertConnectChatToPlatform(obj, _attachmentArgs) {
        throw new Error(`Subclasses must implement the connectChatToPlatform method to translate ${obj}`);
    }
    static satisfiesConnectConstraints(obj, _attachmentArgs) {
        throw new Error(`Subclasses must implement the satisfiesConnectConstraints method to check that platform object ${obj} satisfies Connect constraints`);
    }
    static satisfiesPlatformConstraints(obj, _attachmentArgs) {
        throw new Error(`Subclasses must implement the satisfiesPlatformConstraints method to check that Connect object ${obj} satisfies platform constraints`);
    }
}

const ItemType = {
    TYPING: "TYPING",
    PARTICIPANT_JOINED: "PARTICIPANT_JOINED",
    PARTICIPANT_LEFT: "PARTICIPANT_LEFT",
    CHAT_ENDED: "CHAT_ENDED",
    TRANSFER_SUCCEEDED: "TRANSFER_SUCCEEDED",
    TRANSFER_FAILED: "TRANSFER_FAILED",
    MESSAGE: "MESSAGE",
    EVENT: "EVENT",
    ATTACHMENT: "ATTACHMENT",
    CONNECTION_ACK: "CONNECTION_ACK",
    MESSAGE_DELIVERED: "MESSAGE_DELIVERED",
    MESSAGE_READ: "MESSAGE_READ",
};
const ContentType = {
    EVENT_CONTENT_TYPE: {
        TYPING: "application/vnd.amazonaws.connect.event.typing",
        READ_RECEIPT: "application/vnd.amazonaws.connect.event.message.read",
        DELIVERED_RECEIPT: "application/vnd.amazonaws.connect.event.message.delivered",
        PARTICIPANT_JOINED: "application/vnd.amazonaws.connect.event.participant.joined",
        PARTICIPANT_LEFT: "application/vnd.amazonaws.connect.event.participant.left",
        PARTICIPANT_IDLE: "application/vnd.amazonaws.connect.event.participant.idle",
        PARTICIPANT_DISCONNECT: "application/vnd.amazonaws.connect.event.participant.autodisconnection",
        PARTICIPANT_RETURNED: "application/vnd.amazonaws.connect.event.participant.returned",
        TRANSFER_SUCCEEDED: "application/vnd.amazonaws.connect.event.transfer.succeed",
        TRANSFER_FAILED: "application/vnd.amazonaws.connect.event.transfer.failed",
        CONNECTION_ACKNOWLEDGED: "application/vnd.amazonaws.connect.event.connection.acknowledged",
        AUTHENTICATION_INITIATED: "application/vnd.amazonaws.connect.event.authentication.initiated",
        CHAT_ENDED: "application/vnd.amazonaws.connect.event.chat.ended",
    },
    MESSAGE_CONTENT_TYPE: {
        TEXT_PLAIN: "text/plain",
        TEXT_MARKDOWN: "text/markdown",
        APPLICATION_PDF: "application/pdf",
        IMAGE_JPG: "image/jpeg", // JPEG image (.jpg .jpeg .jfif)
        IMAGE_PNG: "image/png",
        IMAGE_HEIC: "image/heic", // High Efficiency Image File (.heic)
        APPLICATION_DOC: "application/msword",
        APPLICATION_DOCX: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        APPLICATION_XLS: "application/vnd.ms-excel",
        APPLICATION_XLSX: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        TEXT_CSV: "text/csv",
        APPLICATION_PPT: "application/vnd.ms-powerpoint",
        APPLICATION_PPTX: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        AUDIO_WAV: "audio/wav",
        AUDIO_X_WAV: "audio/x-wav", //Firefox
        AUDIO_VND_WAVE: "audio/vnd.wave", //IE
        INTERACTIVE_MESSAGE: "application/vnd.amazonaws.connect.message.interactive",
        INTERACTIVE_RESPONSE: "application/vnd.amazonaws.connect.message.interactive.response",
        VIDEO_QUICKTIME: "video/quicktime", // QuickTime file format (.mov)
        VIDEO_MP4: "video/mp4", // MP4 Video (.mp4)
        RICH_TEXT: "text/richtext", // Rich text (.rtf)
        TEXT_RTF: "text/rtf", // Rich text (.rtf)
        RICH_TEXT_FILE_RTF: "application/rtf", // Rich text (.rtf)
        RICH_TEXT_FILE_X_RTF: "application/x-rtf", // Rich text (.rtf)
    },
    ATTACHMENT_CONTENT_TYPE: {},
};
// structuredClone is not defined in jsdom environment
ContentType.ATTACHMENT_CONTENT_TYPE = {
    TXT: ContentType.MESSAGE_CONTENT_TYPE.TEXT_PLAIN,
    PDF: ContentType.MESSAGE_CONTENT_TYPE.APPLICATION_PDF,
    JPG: ContentType.MESSAGE_CONTENT_TYPE.IMAGE_JPG,
    PNG: ContentType.MESSAGE_CONTENT_TYPE.IMAGE_PNG,
    DOC: ContentType.MESSAGE_CONTENT_TYPE.APPLICATION_DOC,
    DOCX: ContentType.MESSAGE_CONTENT_TYPE.APPLICATION_DOCX,
    XLS: ContentType.MESSAGE_CONTENT_TYPE.APPLICATION_XLS,
    XLSX: ContentType.MESSAGE_CONTENT_TYPE.APPLICATION_XLSX,
    CSV: ContentType.MESSAGE_CONTENT_TYPE.TEXT_CSV,
    PPT: ContentType.MESSAGE_CONTENT_TYPE.APPLICATION_PPT,
    PPTX: ContentType.MESSAGE_CONTENT_TYPE.APPLICATION_PPTX,
    WAV: ContentType.MESSAGE_CONTENT_TYPE.AUDIO_WAV,
    X_WAV: ContentType.MESSAGE_CONTENT_TYPE.AUDIO_X_WAV,
    VND_WAVE: ContentType.MESSAGE_CONTENT_TYPE.AUDIO_VND_WAVE,
    JFIF: ContentType.MESSAGE_CONTENT_TYPE.IMAGE_JPG,
    RTF: ContentType.MESSAGE_CONTENT_TYPE.RICH_TEXT_FILE_RTF,
    X_RTF: ContentType.MESSAGE_CONTENT_TYPE.RICH_TEXT_FILE_X_RTF,
    HEIC: ContentType.MESSAGE_CONTENT_TYPE.IMAGE_HEIC,
    MOV: ContentType.MESSAGE_CONTENT_TYPE.VIDEO_QUICKTIME,
    MP4: ContentType.MESSAGE_CONTENT_TYPE.VIDEO_MP4,
    RICH_TEXT: ContentType.MESSAGE_CONTENT_TYPE.RICH_TEXT,
    TEXT_RTF: ContentType.MESSAGE_CONTENT_TYPE.TEXT_RTF,
};

// Connect data constraints
const CONNECT_MIN_CHARACTER_PER_CHAT_MESSAGE = 1;
const CONNECT_MAX_CHARACTER_PER_CHAT_MESSAGE = 1024;
const CONNECT_MAX_FILE_SIZE_FOR_ATTACHMENT_IN_BYTES = 20 * 2 ** 20; // 20MB
// Salesforce data constraints
const SF_MAX_CHARACTER_FOR_PLAIN_TEXT = 32768;
/* Salesforce's platform allows attachments up to 25MB, but currently we will
 * only be able to support attachments up to 5MB due to platform limits restricting
 * the total size of an HTTP request made from synchronous Apex
 */
const SF_MAX_FILE_SIZE_FOR_ATTACHMENT_IN_BYTES = 5 * 2 ** 20; // 5MB

class SalesforceMessagingDataConverter extends MessagingDataConverterBase {
    static convertPlatformToConnectChat(obj, _attachmentArgs) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let convertedObj = null;
        if (((_a = obj.entryPayload.abstractMessage) === null || _a === void 0 ? void 0 : _a.messageType) ===
            "StaticContentMessage" &&
            ((_b = obj.entryPayload.abstractMessage.staticContent) === null || _b === void 0 ? void 0 : _b.formatType) === "Text") {
            convertedObj = {
                contentType: ContentType.MESSAGE_CONTENT_TYPE.TEXT_PLAIN,
                message: obj.entryPayload.abstractMessage.staticContent.text,
            };
        }
        else if (((_c = obj.entryPayload.abstractMessage) === null || _c === void 0 ? void 0 : _c.messageType) ===
            "StaticContentMessage" &&
            ((_d = obj.entryPayload.abstractMessage.staticContent) === null || _d === void 0 ? void 0 : _d.formatType) ===
                "Attachments" &&
            ((_f = (_e = obj.entryPayload.abstractMessage.staticContent) === null || _e === void 0 ? void 0 : _e.attachments) === null || _f === void 0 ? void 0 : _f.length)) {
            // TODO: add cases for ATTACHMENT, TYPING_START, etc.
            let convertedAttachments = [];
            for (const attachment of (_h = (_g = obj.entryPayload.abstractMessage.staticContent) === null || _g === void 0 ? void 0 : _g.attachments) !== null && _h !== void 0 ? _h : []) {
                let metadata = {
                    url: attachment.url,
                };
                let convertedAttachmentItem = {
                    attachmentId: attachment.id,
                    metadata: metadata,
                };
                convertedAttachments.push(convertedAttachmentItem);
            }
            convertedObj = convertedAttachments;
            // TODO: add cases for non static message (i.e. interactive msgs)
        }
        else {
            // TODO emit metric
            console.log("UnsupportedOperationException: type not supported yet");
        }
        return convertedObj;
    }
    /* for attachment types, only expecting 1 attachment file because SF Interaction api only allows for 1 attachment per call */
    static convertConnectChatToPlatform(obj, attachmentArgs) {
        let convertedObj = null;
        if (obj.Type === ItemType.MESSAGE) {
            if (obj.ContentType === ContentType.MESSAGE_CONTENT_TYPE.TEXT_PLAIN ||
                // SF does not yet support markdown, but messages from Connect customers are often
                // sent through as markdown. Treat the same as plaintext for now. If/when SF adds
                // support for this in the future, additional conversion may be necessary on the
                // content itself.
                obj.ContentType === ContentType.MESSAGE_CONTENT_TYPE.TEXT_MARKDOWN) {
                convertedObj = {
                    timestamp: obj.AbsoluteTime
                        ? new Date(obj.AbsoluteTime).getTime()
                        : undefined,
                    interactionType: "EntryInteraction",
                    payload: {
                        id: obj.Id,
                        entryType: "Message",
                        abstractMessage: {
                            messageType: "StaticContentMessage",
                            id: obj.Id,
                            staticContent: {
                                formatType: "Text",
                                text: obj.Content,
                            },
                        },
                    },
                };
            }
        }
        else if (obj.Type === ItemType.ATTACHMENT) {
            convertedObj = {
                timestamp: obj.AbsoluteTime
                    ? new Date(obj.AbsoluteTime).getTime()
                    : undefined,
                interactionType: "AttachmentInteraction",
                id: obj.Id,
                attachmentIndex: 0,
                contentLength: attachmentArgs === null || attachmentArgs === void 0 ? void 0 : attachmentArgs[0].size, // in bytes
                text: "",
            };
        }
        else {
            // TODO emit metric
            console.log("UnsupportedOperationException: type not supported yet");
        }
        return convertedObj;
    }
    static satisfiesConnectConstraints(obj, attachmentArgs) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (((_a = obj.entryPayload.abstractMessage) === null || _a === void 0 ? void 0 : _a.messageType) ===
            "StaticContentMessage" &&
            ((_b = obj.entryPayload.abstractMessage.staticContent) === null || _b === void 0 ? void 0 : _b.formatType) === "Text") {
            return (((_f = (_e = (_d = (_c = obj.entryPayload.abstractMessage) === null || _c === void 0 ? void 0 : _c.staticContent) === null || _d === void 0 ? void 0 : _d.text) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0) >=
                CONNECT_MIN_CHARACTER_PER_CHAT_MESSAGE &&
                ((_k = (_j = (_h = (_g = obj.entryPayload.abstractMessage) === null || _g === void 0 ? void 0 : _g.staticContent) === null || _h === void 0 ? void 0 : _h.text) === null || _j === void 0 ? void 0 : _j.length) !== null && _k !== void 0 ? _k : 0) <=
                    CONNECT_MAX_CHARACTER_PER_CHAT_MESSAGE);
        }
        else if (((_l = obj.entryPayload.abstractMessage) === null || _l === void 0 ? void 0 : _l.messageType) ===
            "StaticContentMessage" &&
            ((_m = obj.entryPayload.abstractMessage.staticContent) === null || _m === void 0 ? void 0 : _m.formatType) ===
                "Attachments") {
            const satisfiesSupportedFileTypes = ((_o = obj.entryPayload.abstractMessage.staticContent.attachments) !== null && _o !== void 0 ? _o : []).every((attachment) => {
                return Object.values(ContentType.ATTACHMENT_CONTENT_TYPE).includes(attachment.mimeType);
            });
            return (satisfiesSupportedFileTypes &&
                isValidAttachmentsSize(attachmentArgs, CONNECT_MAX_FILE_SIZE_FOR_ATTACHMENT_IN_BYTES));
        }
        return false;
    }
    static satisfiesPlatformConstraints(obj, attachmentArgs) {
        if (obj.Type === ItemType.MESSAGE && obj.Content) {
            return obj.Content.length <= SF_MAX_CHARACTER_FOR_PLAIN_TEXT;
        }
        else if (obj.Type === ItemType.ATTACHMENT) {
            return isValidAttachmentsSize(attachmentArgs, SF_MAX_FILE_SIZE_FOR_ATTACHMENT_IN_BYTES);
        }
        return false;
    }
}

class SalesforceFrontendEventDataConverter extends MessagingDataConverterBase {
    static convertPlatformToConnectChat(message, _attachmentArgs) {
        return {
            contentType: ContentType.MESSAGE_CONTENT_TYPE.TEXT_PLAIN,
            message,
        };
    }
    static satisfiesConnectConstraints(message, attachmentArgs) {
        if (attachmentArgs === null || attachmentArgs === void 0 ? void 0 : attachmentArgs.length) {
            const satisfiesSupportedFileTypes = attachmentArgs.every((attachment) => {
                return Object.values(ContentType.ATTACHMENT_CONTENT_TYPE).includes(attachment.mimeType);
            });
            return (satisfiesSupportedFileTypes &&
                isValidAttachmentsSize(attachmentArgs, CONNECT_MAX_FILE_SIZE_FOR_ATTACHMENT_IN_BYTES));
        }
        else {
            // static content
            return (message.length >= CONNECT_MIN_CHARACTER_PER_CHAT_MESSAGE &&
                message.length <= CONNECT_MAX_CHARACTER_PER_CHAT_MESSAGE);
        }
    }
}

exports.MessagingDataConverterBase = MessagingDataConverterBase;
exports.SalesforceFrontendEventDataConverter = SalesforceFrontendEventDataConverter;
exports.SalesforceMessagingDataConverter = SalesforceMessagingDataConverter;
//# sourceMappingURL=index.js.map
